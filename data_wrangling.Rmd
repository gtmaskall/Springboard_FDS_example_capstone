---
title: 'Data wrangling'
author: 'Guy Maskall'
date: '`r format(Sys.Date(), "%d %B, %Y")`'
output:
    html_document:
        toc: true
    pdf_document:
        toc: true
---

# RBD/RBMP data

## Introduction

This report documents the process of obtaining and preparing the
River Severn basin district data. The main download page is
[here](http://environment.data.gov.uk/catchment-planning/RiverBasinDistrict/9).
There are a number of files already identified as potentially relevant.
The first step is to download them so they can be read into R. We shall do this
programmatically so thereby having a script that can be run on multiple computers
and will obtain the original data on its first run.

```{r, setup}
library(tidyverse)
```

## Download and verify RBD data

In the code chunk below we specify the data we want to obtain and ensure it
is available and as expected.

```{r, downloads}
library(tools) # for md5sum
#NB previous exploration has shown us we end up with zip files
class_file <- "Data/classifications.zip"
class_url <- paste0("http://environment.data.gov.uk/catchment-planning/",
                    "RiverBasinDistrict/9/classification?item=all&status=all",
                    "&format=csv")
class_md5 <- "6d90201502183a9b5bf489d7b6e5a212"

measures_file <- "Data/measures.zip"
measures_url <- paste0("http://environment.data.gov.uk/catchment-planning/",
                       "RiverBasinDistrict/9/Action?format=csv")
measures_md5 <- "ac5eb5ce96871ab4d3dcc59d30a917e1"

objectives_file <- "Data/objectives.zip"
objectives_url <- paste0("http://environment.data.gov.uk/catchment-planning/",
                         "RiverBasinDistrict/9/outcome?item=all&status=all",
                         "&format=csv")
objectives_md5 <- "7d93caa97c087115c9f9f17f1667a8eb"

reasons_file <- "Data/reasons.zip"
reasons_url <- paste0("http://environment.data.gov.uk/catchment-planning/",
                      "RiverBasinDistrict/9/ReasonsForNotAchievingGood?item=all",
                      "&format=csv")
reasons_md5 <- "54f5363d8fad58ed9cdf9cff9c9b7d4c"

waterbody_file <- "Data/waterbody_links.zip"
waterbody_url <- paste0("http://environment.data.gov.uk/catchment-planning/",
                        "RiverBasinDistrict/9/pa/csv")
waterbody_md5 <- "1a6bb38a52e22d04b7898aadcb7181bb"

if (!dir.exists("Data")) {
    dir.create("Data")
}

if (!file.exists(class_file)) {
    download.file(class_url, class_file)
}

if (!file.exists(measures_file)) {
    download.file(measures_url, measures_file)
}

if (!file.exists(objectives_file)) {
    download.file(objectives_url, objectives_file)
}

if (!file.exists(reasons_file)) {
    download.file(reasons_url, reasons_file)
}

if (!file.exists(waterbody_file)) {
    download.file(waterbody_url, waterbody_file)
}

# check md5
check_md5 <- function(filename, md5) {
    if (md5sum(filename) != md5) {
        message(filename, " does not match expected md5sum")
    } else {
        message(filename, " matches expected md5sum: ", md5)
    }
}

check_md5(class_file, class_md5)
check_md5(measures_file, measures_md5)
check_md5(objectives_file, objectives_md5)
check_md5(reasons_file, reasons_md5)
check_md5(waterbody_file, waterbody_md5)
```

The md5sum checks above are against the md5sums calculated on an initial download
of the data. Files, particularly online, can change. Successful md5sum checks
here confirm that the files are identical to those expected by this analysis and
thus should yield reproducible results.

## Initial data view

### Classification data

Reading in the classification file (a CSV within a zip), and performing a basic
check, we see the following.

```{r, read_class}
classification <- read_csv("Data/classifications.zip")
classification %>% glimpse
classification %>% summarise_all(funs(sum(is.na(.)))) %>% gather(column, num_NA)
# remove the original endpoint URL
classification <- classification %>%
    select(-`classification ID`)
```

From the output above we can see that the column data types have been reasonably
and correctly guessed. The only missing values are in the Certainty, Confidence,
and Investigation Outcome columns. This is no concern at the moment. The main
data issues so far are the lack of a data dictionary. The interpretation of
many columns is obvious, but some require some care.

A description of the Management catchment can be found in the glossary
[here](http://environment.data.gov.uk/catchment-planning/glossary#m) where
we see a management catchment is

>an amalgamation of a number of river water body catchments that provide
>a management unit at which level actions are applied. Management catchments are
>hydrological management areas. They are built up from river water body
>catchments into similar sized management units, of a scale that suits
>management and planning from an Environment Agency perspective. All the land
>area of England and Wales is divided into management catchments, so they
>include the coastline as part of their definition. They do not have a formal
>statutory reporting role.

Similarly, an operation catchment is

>an amalgamation of a small number of river water body catchments. Operational
>catchments are smaller units, as a rule, than management catchments. They are
>used in the economic analysis process to identify packages of measures that can
>be applied to improve the ecological status of the water bodies within it

and a water body is

>a unit of surface water, being the whole (or part) of a stream, river or canal,
>lake or reservoir, estuary or stretch of coastal water. A groundwater water
>body is a defined area of an aquifer with geological and hydrological
>boundaries to ensure consistency and avoid fragmentation.

The hydromorphology of a water body is described to be

>the hydrological and geomorphological processes and attributes of surface water
>bodies. For example for rivers, hydromorphology describes the form and function
>of the channel as well as its connectivity (up and downstream and with
>groundwater) and flow regime, which defines its ability to allow migration of
>aquatic organisms and maintain natural continuity of sediment transport through
>the fluvial system. The Water Framework Directive requires surface waters to be
>managed in such a way as to safeguard their hydrology and geomorphology so that
>ecology is protected.

The classification hierarchy is described clearly and graphically
[here](http://environment.data.gov.uk/catchment-planning/help#help-classification-hierarchy).

### Measures data

The measures data contains a relatively small number of planned measures
(works) as shown below.


```{r, read_measures}
measures <- read_csv("Data/measures.zip")
measures %>% glimpse
measures %>% summarise_all(funs(sum(is.na(.)))) %>% gather(column, num_NA)
```

Useful columns definitely seem to be Waterbody ID, which could be linked back
to the classifications data. RNAG means "Reason for not achieving good" and will
link to another table. Most columns are character, although the estimated start
date is correctly read in as a date. There are a few missing values limited to
estimated start date, a measure category, and funding/organization. The meaning
of Measure type (e.g. "WBLMA") is not currently understood.

### Objectives

The value of the objectives data is less certain. Many columns have already
been seen and the main addition seems to be the ObjectiveType column, which
can hold either the value "Objective" or "Predicted".
The only missing values are in the "Reasons for Alternative Objectives" column,
which does not seem crucial.

```{r, read_objectives}
objectives <- read_csv("Data/objectives.zip")
objectives %>% glimpse
objectives %>% summarise_all(funs(sum(is.na(.)))) %>% gather(column, num_NA)
# remove the original endpoint URLs
objectives <- objectives %>%
    select(-c(`River Basin District URI`,
              `Management Catchment URI`,
              `Operational Catchment URI`))
```

### Reasons

The reasons data is understood to contain data pertaining to
"Reasons for not achieving good". As such, there is an Id column that should
be useful for linking with Linked RNAG in the measures data. Thus these two
datasets together could be interesting for relating water bodies that failed
to achieve good status with measures (planned) for remediating that.

```{r, read_reasons}
reasons <- read_csv("Data/reasons.zip")
reasons %>% glimpse
reasons %>% 
    summarise_all(funs(sum(is.na(.)))) %>% 
    gather(column, num_NA) %>%
    print(n = Inf)
# remove original endpoint for RNAG URL (we have the ID)
reasons <- reasons %>%
    select(-`Rnag URL`)
```

We see there are currently unknown column values such as "RFF" in the Reason
type column. The columns with names referring to Pressure Tier are also
currently not understood, as as Swmi.
There are some missing values in the Pressure tier columns, for example, but
these will be assessed once the meaning of those columns is better known.

### Waterbody links

```{r, read_waterbody}
waterbody <- read_csv("Data/waterbody_links.zip")
waterbody %>% glimpse
waterbody %>% summarise_all(funs(sum(is.na(.)))) %>% gather(column, num_NA)
```

## Data deduplication

It is clear that there are a number of columns that appear in multiple, if not
all dataframes. These are (with some minor name differences):

* Water body ID
* Water body type
* Water body
* Operational catchment
* Management catchment
* River basin district

Not only does this mean we carry around redundant, duplicated columns, we
also risk confusion with multiple, but subtly different columns occuring in the
same dataframe after any join operation. A convenient task now is to extract
those columns into a separate dataframe and leave only the water body ID in
the original dataframe with which we can join the data. This is on the
understanding that the water body ID is the unique key. Furthermore, we can
check this assumption that water body ID is unique.

```{r, extract_wb}
# Settle on the convention:
# Waterbody_ID
# Waterbody_type
# Waterbody
# Operational_catchment
# Management_catchment
# RBD
# Easting
# Northing
# NGR

# Assume here the easting, northing, and NGR refer to a particular
# water body ID.
class_wb <- classification %>%
    select(Waterbody_ID = `Waterbody ID`,
           Waterbody_type = `Water body type`,
           Waterbody = `water body`,
           Operational_catchment = `Operational catchment`,
           Management_catchment = `Management catchment`,
           RBD = `River basin district`,
           Easting,
           Northing,
           NGR = Ngr) %>%
    distinct

class_wb %>% count(`Waterbody_ID`) %>% filter(n > 1)

measures_wb <- measures %>%
    select(Waterbody_ID = `Waterbody ID`,
           Operational_catchment = `Operational Catchment`,
           Management_catchment = `Management Catchment`,
           RBD = `River Basin District`) %>%
    distinct

measures_wb %>% count(`Waterbody_ID`) %>% filter(n > 1)

# It's not clear at the moment whether hydromorphological designation
# is constant for a given water body so we won't extract this now.
objectives_wb <- objectives %>%
    select(Waterbody_ID = `Waterbody ID`,
           Waterbody_type = `Water body type`,
           Waterbody = `water body`,
           Operational_catchment = `Operational Catchment`,
           Management_catchment = `Management Catchment`,
           RBD = `River Basin District`,
           Easting,
           Northing,
           NGR = Ngr) %>%
    distinct

objectives_wb %>% count(`Waterbody_ID`) %>% filter(n > 1)

reasons_wb <- reasons %>%
    select(Waterbody_ID = `Water body id`,
           Waterbody_type = `Water body type`,
           Waterbody = `water body`,
           Operational_catchment = `Operational Catchment`,
           Management_catchment = `Management Catchment`,
           RBD = `River Basin District`) %>%
    distinct

reasons_wb %>% count(`Waterbody_ID`) %>% filter(n > 1)

waterbody_wb <- waterbody %>%
    select(Waterbody_ID = `Waterbody ID`,
           Operational_catchment = `Operational catchment`,
           Management_catchment = `Management catchment`,
           RBD = `River basin district`) %>%
    distinct

waterbody_wb %>% count(`Waterbody_ID`) %>% filter(n > 1)

class_meas <- full_join(class_wb, measures_wb)
class_meas %>% filter(is.na(Waterbody_type))
# This highlights something I remember - some IDs seem combined!
# Find them and decide how to deal with them!
```

The combined water body IDs originate from the measures table, as shown
below:

```{r, measures_combines_wb_ID}
measures %>% 
    filter(str_detect(`Waterbody ID`, "\\|")) %>% 
    glimpse

# e.g.
measures %>%
    filter(ID == 39579) %>%
    glimpse
```

Looking at the rows containing the "|" character, we find there are four such 
measures rows, each with their own ID. We also see the Linked RNAGs column
contains merged IDs. From this we piece together the picture that each of 
these four measures are associated with more than one water body ID and its
reason for not achieving good. This makes it harder to associate a water body
ID with an associated measure and so we prefer to split these records out into
separate rows. We can do this by splitting and unnesting on the two affected
columns:

```{r, separate_measure_rows}
measures <- measures %>% 
    filter(str_detect(`Waterbody ID`, "\\|")) %>% 
    mutate(`Waterbody ID` = str_split(`Waterbody ID`, "\\|"), 
           `Linked RNAGs` = str_split(`Linked RNAGs`, "\\|")) %>% 
    unnest(`Waterbody ID`, `Linked RNAGs`)

# e.g.
measures %>%
    filter(ID == 39579) %>%
    glimpse

#regenerate the measures_wb table
measures_wb <- measures %>%
    select(Waterbody_ID = `Waterbody ID`,
           Operational_catchment = `Operational Catchment`,
           Management_catchment = `Management Catchment`,
           RBD = `River Basin District`) %>%
    distinct

measures_wb %>% count(`Waterbody_ID`) %>% filter(n > 1)
```

We now have a separate row for each water body ID and Linked RNAG at the cost
of duplicate measure IDs. We should remember this if analysing data at the 
measure-level in future.

The classification and objectives tables contain a full set of our "water body"
columns, namely:

* Waterbody ID
* Waterbody type
* Waterbody
* Operational catchment
* Management catchment
* River basin district
* Easting
* Northing
* NGR

If we combine all these columns for both of these tables, we hope to get no
duplicated waterbody IDs, thus:

```{r, full_wb_check}
full_wb <- bind_rows(class_wb, objectives_wb) %>%
    distinct 

full_wb %>% 
    count(Waterbody_ID) %>% 
    filter(n > 1)
```

The above result shows that combining all rows from both tables yields no
duplicated water body IDs; each ID is associated with a unique combination
of type, name, location etc.

Similarly, the measures and waterbody tables share the columns

* Waterbody ID
* Operational catchment
* Management catchment
* River basin district

and we can repeat the above process to check for duplicates
(non-unique waterbody ID) thus:

```{r, meas_wb_check}
min_wb <- bind_rows(measures_wb, waterbody_wb) %>%
    distinct 

min_wb %>% 
    count(Waterbody_ID) %>% 
    filter(n > 1)
```

The above null result confirms there are no duplicated waterbody IDs (with
different values in the other columns).

The reasons table contains columns for water body type and waterbody that our
new min_wb does not. If we were to simply combine rows we would possibly end 
up with duplicate waterbody IDs because of some NAs for values in the min_wb
table. To merge these tables and check for uniqueness of the waterbody ID we
can employ another method and perform a join that preserves all rows but
effectives merges any duplicates:

```{r, merge_min_reason_check}
min_wb <- min_wb %>% 
    full_join(reasons_wb)

min_wb %>% glimpse

min_wb %>%
    count(Waterbody_ID) %>%
    filter(n > 1)

min_wb %>%
    summarise_all(funs(sum(is.na(.)))) %>%
    gather(column, num_NA)
```

The above results show that after the join, there are no rows with duplicated
waterbody ID and no rows where waterbody ID is missing. Thus all rows describe
a one-to-one mapping of waterbody ID to other parameters. Note there are some
waterbody IDs for which waterbody type and waterbody are unknown.

Finally we can employ the same method again to do a last join between the first
full set of waterbody parameters and this recent, less comprehensive, set of
parameters.

```{r, final_wb_join_check}
full_wb <- full_wb %>% 
    full_join(min_wb)

full_wb %>% glimpse

full_wb %>%
    count(Waterbody_ID) %>%
    filter(n > 1)

full_wb %>%
    summarise_all(funs(sum(is.na(.)))) %>%
    gather(column, num_NA)
```

The above results show us there are now 88 duplicated waterbody ID and, by
a suspicious coincidence, 88 NAs for waterbody type, waterbody, easting,
northing, and NGR. A spot check of the first duplicated Waterbody ID shows
that, indeed, it is duplicated because one set of values is NA:

```{r, dup_wb_ID_check}
full_wb %>% 
    select(Waterbody_ID, Waterbody_type, Waterbody, Easting, Northing, NGR) %>% 
    filter(Waterbody_ID == "GB109053022030") %>% 
    glimpse
```

We can attempt to resolve this with the following recipe:

1. group by waterbody ID
2. mutate each column affected with NAs, replacing NAs with the first non-NA
3. retain only distinct rows

The step of taking the first NA value ensures the method should work even if
somehow there were multiple non-NA values. It would then be arbitrary which
value was used, but this won't matter if the values are the same. If the values
are different, a problem will still show up later on.

```{r, final_wb_fix}
# It's worth documenting what this mutate_at is doing:
# The first argument is the list of columns we want to operate on,
# the . denotes the column currently being operated on,
# the rule is then simply "if a value is NA, replace it with the
# first non-NA value, else leave it unchanged.
# (NB sometimes even the more experience of us are amazed and impressed
# that something works as intended)!
full_wb <- full_wb %>% 
    group_by(Waterbody_ID) %>% 
    mutate_at(c("Waterbody_type", "Waterbody", "Easting", "Northing", "NGR"),
              funs(if_else(is.na(.), .[!is.na(.)][1], .))) %>% 
    ungroup

full_wb %>% 
    select(Waterbody_ID, Waterbody_type, Waterbody, Easting, Northing, NGR) %>% 
    filter(Waterbody_ID == "GB109053022030") %>% 
    glimpse

# now that we've rechecked the above ID, we can remove duplicates
full_wb <- distinct(full_wb)

full_wb %>%
    count(Waterbody_ID) %>%
    filter(n > 1)

full_wb %>%
    summarise_all(funs(sum(is.na(.)))) %>%
    gather(column, num_NA)

full_wb %>% saveRDS("Data/waterbody.rds")
```

This seems to confirm we have now gathered together and merged all our waterbody
details into a single table with no duplicated waterbody ID and no missing
values!


## Final data tables

We can now create our stripped down tables to be accompanied by this new
table of waterbody details.

```{r, final_tables}
classification <- classification %>%
    select(-c(`River basin district`, 
              `Management catchment`, 
              `Operational catchment`, 
              `water body`, 
              `Water body type`, 
              `Easting`, 
              `Northing`, 
              `Ngr`)) %>%
    rename(Waterbody_ID = `Waterbody ID`)

classification %>% glimpse
classification %>% saveRDS("Data/classification.rds")

measures <- measures %>%
    select(-c(`River Basin District`,
              `Management Catchment`,
              `Operational Catchment`)) %>%
    rename(Waterbody_ID = `Waterbody ID`)

measures %>% glimpse
measures %>% saveRDS("Data/measures.rds")

objectives <- objectives %>%
    select(-c(`River Basin District`,
              `Management Catchment`,
              `Operational Catchment`,
              `water body`,
              `Water body type`,
              Easting,
              Northing,
              Ngr)) %>%
    rename(Waterbody_ID = `Waterbody ID`)

objectives %>% glimpse
objectives %>% saveRDS("Data/objectives.rds")

reasons <- reasons %>%
    select(-c(`River Basin District`,
              `Management Catchment`,
              `Operational Catchment`,
              `water body`,
              `Water body type`)) %>%
    rename(Waterbody_ID = `Water body id`)

reasons %>% glimpse
reasons %>% saveRDS("Data/reasons.rds")

waterbody <- waterbody %>%
    select(-c(`River basin district`,
              `Management catchment`,
              `Operational catchment`)) %>%
    rename(Waterbody_ID = `Waterbody ID`)

waterbody %>% glimpse
# more appropriate name for this file as it relates
# water body IDs to protected area details
waterbody %>% saveRDS("Data/protected_area.rds")
```

## Summary

The data seem to be of general good quality. The first issue was
understanding and interpreting some columns. There will be some work
remaining on this. The next issue was identifying some duplicate columns
across the various tables and some work was put in to extract those
columns into a new table and check for any duplicates and other issues,
one of which was found to be some IDs being merged in one table.
